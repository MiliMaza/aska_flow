import { N8nWorkflow } from "@/lib/workflow-schema";

interface SecurityScanResult {
  isSafe: boolean;
  reason?: string;
}

// N8N nodes that are too dangerous to be generated by AI
const DISALLOWED_NODE_TYPES = new Set([
  "executeCommand",
  "n8n-nodes-base.ssh",
  "n8n-nodes-base.fileSystem",
]);

// REGEX patterns to detect local or internal networks
const LOCAL_URL_PATTERNS = [
  /^https?:\/\/localhost/i,
  /^https?:\/\/127\.\d+\.\d+\.\d+/i,
  /^https?:\/\/192\.168\.\d+\.\d+/i,
  /^https?:\/\/10\.\d+\.\d+\.\d+/i,
];

// REGEX patters to detect dangerous JS code expressions
const DANGEROUS_EXPRESSION_PATTERNS = [
  /eval\(/,
  /require\(/,
  /process\./,
  /fs\./,
  /child_process/,
];

// Scans the workflow object to do a security check
export function securityScan(workflow: N8nWorkflow): SecurityScanResult {
  // Verify that no disallowed node types are present
  for (const node of workflow.nodes) {
    if (DISALLOWED_NODE_TYPES.has(node.type)) {
      return {
        isSafe: false,
        reason: `Node type "${node.type}" is disallowed for security reasons.`,
      };
    }
  }

  // Scan for unsafe URLs and dangerous expressions
  const workflowString = JSON.stringify(workflow);

  for (const pattern of LOCAL_URL_PATTERNS) {
    if (pattern.test(workflowString)) {
      return {
        isSafe: false,
        reason: "Workflow contains a potentially unsafe local URL.",
      };
    }
  }

  for (const pattern of DANGEROUS_EXPRESSION_PATTERNS) {
    if (pattern.test(workflowString)) {
      return {
        isSafe: false,
        reason: "Workflow contains a potentially dangerous code expression.",
      };
    }
  }

  return { isSafe: true };
}
